import { type AclAssignment, type DacumentEventMap, type DocFieldAccess, type DocSnapshot, type RoleKeys, type RolePublicKeys, type SchemaDefinition, type SchemaId, type SignedOp, type Role, array, map, record, register, set, text } from "./types.js";
export declare class Dacument<S extends SchemaDefinition> {
    private static actorId?;
    static setActorId(actorId: string): void;
    private static requireActorId;
    private static isValidActorId;
    static schema: <Schema extends SchemaDefinition>(schema: Schema) => Schema;
    static register: typeof register;
    static text: typeof text;
    static array: typeof array;
    static set: typeof set;
    static map: typeof map;
    static record: typeof record;
    static computeSchemaId(schema: SchemaDefinition): Promise<SchemaId>;
    static create<Schema extends SchemaDefinition>(params: {
        schema: Schema;
        docId?: string;
    }): Promise<{
        docId: string;
        schemaId: SchemaId;
        roleKeys: RoleKeys;
        snapshot: DocSnapshot;
    }>;
    static load<Schema extends SchemaDefinition>(params: {
        schema: Schema;
        roleKey?: JsonWebKey;
        snapshot: DocSnapshot;
    }): Promise<DacumentDoc<Schema>>;
    readonly docId: string;
    readonly actorId: string;
    readonly schema: S;
    readonly schemaId: SchemaId;
    private readonly fields;
    private readonly aclLog;
    private readonly clock;
    private readonly roleKey?;
    private readonly roleKeys;
    private readonly opLog;
    private readonly opTokens;
    private readonly verifiedOps;
    private readonly appliedTokens;
    private currentRole;
    private readonly revokedCrdtByField;
    private readonly deleteStampsByField;
    private readonly tombstoneStampsByField;
    private readonly deleteNodeStampsByField;
    private readonly eventListeners;
    private readonly pending;
    private readonly ackByActor;
    private suppressMerge;
    private ackScheduled;
    private lastGcBarrier;
    private snapshotFieldValues;
    readonly acl: {
        setRole: (actorId: string, role: Role) => void;
        getRole: (actorId: string) => Role;
        knownActors: () => string[];
        snapshot: () => AclAssignment[];
    };
    constructor(params: {
        schema: S;
        schemaId: SchemaId;
        docId: string;
        roleKey?: JsonWebKey;
        roleKeys: RolePublicKeys;
    });
    addEventListener<K extends keyof DacumentEventMap>(type: K, listener: (event: DacumentEventMap[K]) => void): void;
    removeEventListener<K extends keyof DacumentEventMap>(type: K, listener: (event: DacumentEventMap[K]) => void): void;
    flush(): Promise<void>;
    snapshot(): DocSnapshot;
    merge(input: SignedOp | SignedOp[] | string | string[]): Promise<{
        accepted: SignedOp[];
        rejected: number;
    }>;
    private rebuildFromVerified;
    private ack;
    private scheduleAck;
    private computeGcBarrier;
    private maybeGc;
    private compactFields;
    private compactListField;
    private compactTombstoneField;
    private setRegisterValue;
    private createFieldView;
    private shadowFor;
    private isRevoked;
    private readCrdt;
    private revokedCrdt;
    private stampMapFor;
    private setMinStamp;
    private recordDeletedNode;
    private recordTombstone;
    private recordDeleteNodeStamp;
    private createTextView;
    private createArrayView;
    private createSetView;
    private createMapView;
    private createRecordView;
    private commitArrayMutation;
    private commitSetMutation;
    private commitMapMutation;
    private commitRecordMutation;
    private capturePatches;
    private queueLocalOp;
    private applyRemotePayload;
    private applyAclPayload;
    private applyRegisterPayload;
    private applyNodePayload;
    private applySetNodes;
    private applyMapNodes;
    private applyRecordNodes;
    private validateDagNodeValues;
    private emitListOps;
    private diffSet;
    private diffMap;
    private diffRecord;
    private emitInvalidationDiffs;
    private emitFieldDiff;
    private emitTextDiff;
    private emitArrayDiff;
    private arrayEquals;
    private commonPrefix;
    private commonSuffix;
    private setRole;
    private recordValue;
    private mapValue;
    private fieldValue;
    private emitEvent;
    private emitMerge;
    private emitRevoked;
    private emitError;
    private canWriteField;
    private canWriteAcl;
    private canWriteAclTarget;
    private assertWritable;
    private assertValueType;
    private assertValueArray;
    private assertMapKey;
    private isValidPayload;
    private assertSchemaKeys;
}
export type DacumentDoc<S extends SchemaDefinition> = Dacument<S> & DocFieldAccess<S>;
